{"texts": {"0": "To edit a video, use `ffmpeg`", "1": "For audio effects, use `pedalboard`", "2": "For file conversion, use `pandoc`", "3": "To download a YouTube video, use `yt-dlp`. If the user specified a format/extension, specify that format in `yt-dlp`.", "4": "If you encounter a traceback, don't try to use an alternative method yet. Instead:\n\n**Write a message to the user explaining what happened and theorizing why. Do not try to run_code immediatly after run_code has errored.**\n\nIf a solution is apparent (and is not simply changing methods / using a new package) attempt it.\nIf not, list these steps in a message to the user, then follow them one-by-one:\n\n1. Create and run a minimal reproducible example.\n2. Use dir() to verify correct imports. There may be a better object to import from the module.\n3. Print docstrings of functions/classes using print(func.__doc__).\n\nOnly then are you permitted to use an alternative method.", "5": "To play a YouTube video, use `selenium`:\n\n- Open Chrome\n- Navigate to YouTube\n- Find the search bar\n- Input the search query and press Enter\n- Wait for the results to load\n- Click the first video in the results\n- The video should now be playing; you might want to handle advertisements or auto-play as required", "6": "## Saying Things Out Loud / Text-to-speech\n(Mac) Use Applescript: say \"text_to_say\"", "7": "To adjust system settings like dark/light mode, volume, etc:\n(If Mac) Run Applescript.", "8": "To use applications like Mail for reading and writing emails, Calendar for creating and reading calendar events, iTunes for playing and pausing songs, Finder for emptying the trash, etc:\n(Mac) Run Applescript", "9": "# Extract text from a PDF\n\nDon't use PdfFileReader from PyPDF2 to read PDF files as it's deprecated in PyPDF2 version 3.0.0. Instead, use PdfReader:\n\n```python\nfrom PyPDF2 import PdfReader\n\npdf = PdfReader('path_to_your_file.pdf')\ntext = pdf.pages[0].extract_text()\n```", "10": "To summarize something, 99% OF THE TIME YOU CAN SIMPLY NOT WRITE CODE. Simply print/read the text then summarize it manually.\n\nThe vast majority of the time, that^ will be sufficient. ENSURE you can't read all the text at once before moving to the much more expensive languagetools options.\n\nIf the text is of tremendous length, like a book or unseeable by you when you print it (outputs are truncated to 2000 characters), run these commands:\n\n```shell\npip install languagetools\n```\n\n```python\nfrom languagetools import summarizer\n\nsummary = summarizer.summarize(text)\n```", "11": "## (Mac) Get emails\nExecute the following AppleScript command to get the content of the last X (in this case, 3) emails from the Mail application:\ntell application \"Mail\" to get content of messages 1 through 3 of inbox\n\n## (Mac) Send emails\nUse Applescript.", "12": "# Get calendar events\n(Mac) Use `brew install ical-buddy` then something like `ical-buddy eventsFrom:today to:'today+7'`", "13": "## Web Browsing\nPrefer `selenium`.\n\n**IMPORTANT NOTE:** `webdriver_manager` is no longer required to use `selenium`. NEVER INSTALL `webdriver_manager`. Simply use `driver = selenium.webdriver.Chrome()`\n\nTo locate elements on a page:\n\n```\nfrom selenium.webdriver.common.by import By\ndriver.find_element(By.XPATH, '//button[text()=\"Some text\"]')\ndriver.find_elements(By.XPATH, '//button')\n```\n\nAttributes available for By class:\n\n```\nID = \"id\"\nNAME = \"name\"\nXPATH = \"xpath\"\nLINK_TEXT = \"link text\"\nPARTIAL_LINK_TEXT = \"partial link text\"\nTAG_NAME = \"tag name\"\nCLASS_NAME = \"class name\"\nCSS_SELECTOR = \"css selector\"\n```\n\nWith the constraint that you don't have access to any visual tools, here's how you can approach browsing an unknown website:\n\n```python\n# Wait for JavaScript to load, looking for a common element like body\nWebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, 'body')))\n# Find all elements in the body\nbody = driver.find_element(By.TAG_NAME, 'body')\nall_elements = body.find_elements(By.XPATH, \".//*\")\n# Iterate through all elements and print the important ones\nfor element in all_elements:\n    tag_name = element.tag_name.lower()\n    # Print input fields\n    if tag_name == 'input':\n        print(f\"Input - Type: {element.get_attribute('type')}, Name: {element.get_attribute('name')}\")\n    # Print buttons\n    elif tag_name == 'button':\n        print(f\"Button - Text: {element.text}\")\n    # Print links\n    elif tag_name == 'a':\n        print(f\"Link - Href: {element.get_attribute('href')}\")\n    # Print headings\n    elif tag_name in ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']:\n        print(f\"Heading ({tag_name.upper()}) - {element.text}\")\n```", "14": "To make a simple app, use HTML/Bulma CSS/JS.\nFirst, plan. Think deeply about the functionality, what the JS will need to do, and how it will need to work with the HTML.\nThen, **all in one** `html` code block (DO NOT `run_code` more than once, and NEVER use placeholders like \"// Javascript code here\" -- you're going to write the HTML/JS in one `run_code` function call):\nPut Bulma CSS and anything else you need in <head>, write the <body> of the app (add lots of padding on the body with Bulma), write the JS into the <script> tag.\n\nYou probably want to center the app in a box with a border and make sure the body fills up the whole height of the page!\n\nWrite **LOTS of <!--comments--> throughout the HTML and // Javascript** so the user knows what's going on, and use whitespace/indentation properly.\n\nThis will automatically open the HTML file / simple app on the user's machine.", "15": "## Writing HTML\nUnless otherwise specified, include Tailwind CSS IN EXACTLY THIS WAY: `<script src=\"https://cdn.tailwindcss.com\"></script>` (with a SCRIPT tag to \"https://cdn.tailwindcss.com\") then style the HTML with inline Tailwind CSS classes.\nRunning `html` will automatically open it in the user's browser, you don't need to tell them to do that."}}